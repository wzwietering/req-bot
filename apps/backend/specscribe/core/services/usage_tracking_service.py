"""Usage tracking service for quota enforcement."""

import os
from datetime import UTC, datetime, timedelta

from specscribe.core.database_models import UsageEventTable, UserTable
from specscribe.core.services.exceptions import QuotaExceededError, UserNotFoundError
from specscribe.core.storage import DatabaseManager


class UsageTrackingService:
    """Service for tracking and enforcing user quotas."""

    def __init__(self, storage: DatabaseManager):
        self.storage = storage

    def _validate_user_id(self, user_id: str) -> None:
        """Validate user_id is not empty."""
        if not user_id or not user_id.strip():
            raise ValueError("user_id cannot be empty")

    def _validate_entity_id(self, entity_id: str) -> None:
        """Validate entity_id is not empty."""
        if not entity_id or not entity_id.strip():
            raise ValueError("entity_id cannot be empty")

    def record_question_generated(self, user_id: str, question_id: str) -> None:
        """Record that a question was generated for a user."""
        self._validate_user_id(user_id)
        self._validate_entity_id(question_id)

        event = UsageEventTable(
            user_id=user_id, event_type="question_generated", entity_id=question_id, created_at=datetime.now(UTC)
        )
        with self.storage.SessionLocal() as session:
            session.add(event)
            session.commit()

    def record_questions_batch(self, user_id: str, question_ids: list[str]) -> None:
        """Record multiple questions generated for a user in a single transaction."""
        self._validate_user_id(user_id)
        if not question_ids:
            return

        for qid in question_ids:
            self._validate_entity_id(qid)

        now = datetime.now(UTC)
        events = [
            UsageEventTable(user_id=user_id, event_type="question_generated", entity_id=qid, created_at=now)
            for qid in question_ids
        ]

        with self.storage.SessionLocal() as session:
            session.add_all(events)
            session.commit()

    def record_questions_batch_in_transaction(self, db_session, user_id: str, question_ids: list[str]) -> None:
        """Record multiple questions in an existing transaction. Does not commit."""
        self._validate_user_id(user_id)
        if not question_ids:
            return

        for qid in question_ids:
            self._validate_entity_id(qid)

        now = datetime.now(UTC)
        events = [
            UsageEventTable(user_id=user_id, event_type="question_generated", entity_id=qid, created_at=now)
            for qid in question_ids
        ]
        db_session.add_all(events)

    def record_answer_submitted(self, user_id: str, answer_id: str) -> None:
        """Record that an answer was submitted by a user."""
        self._validate_user_id(user_id)
        self._validate_entity_id(answer_id)

        event = UsageEventTable(
            user_id=user_id, event_type="answer_submitted", entity_id=answer_id, created_at=datetime.now(UTC)
        )
        with self.storage.SessionLocal() as session:
            session.add(event)
            session.commit()

    def count_questions_in_window(self, user_id: str, days: int = 30) -> int:
        """Count questions generated by user in the last N days."""
        self._validate_user_id(user_id)
        if days <= 0:
            raise ValueError("days must be positive")
        return self._query_question_count(user_id, days)

    def get_quota_limit(self, tier: str) -> int:
        """Get quota limit for a given tier."""
        limits = {
            "free": int(os.getenv("FREE_TIER_QUESTION_LIMIT", "10")),
            "pro": int(os.getenv("PRO_TIER_QUESTION_LIMIT", "10000")),
        }
        return limits.get(tier, limits["free"])

    def check_quota_available(self, user_id: str, tier: str) -> None:
        """Check if user has quota available. Raises QuotaExceededError if not."""
        window_days = int(os.getenv("QUOTA_WINDOW_DAYS", "30"))
        current_usage = self.count_questions_in_window(user_id, window_days)
        limit = self.get_quota_limit(tier)

        if current_usage >= limit:
            raise QuotaExceededError(current_usage, limit, window_days)

    def get_user_usage_stats(self, user_id: str) -> dict:
        """Get usage statistics for a user."""
        window_days = int(os.getenv("QUOTA_WINDOW_DAYS", "30"))

        with self.storage.SessionLocal() as session:
            user = session.get(UserTable, user_id)
            if not user:
                raise UserNotFoundError(user_id)

            tier = user.tier

        questions_count = self.count_questions_in_window(user_id, window_days)
        answers_count = self._count_answers_in_window(user_id, window_days)
        limit = self.get_quota_limit(tier)

        return {
            "questions_generated": questions_count,
            "answers_submitted": answers_count,
            "quota_limit": limit,
            "quota_remaining": max(0, limit - questions_count),
            "window_days": window_days,
        }

    def _query_question_count(self, user_id: str, days: int) -> int:
        """Query database for question count in window."""
        cutoff = datetime.now(UTC) - timedelta(days=days)

        with self.storage.SessionLocal() as session:
            count = (
                session.query(UsageEventTable)
                .filter(
                    UsageEventTable.user_id == user_id,
                    UsageEventTable.event_type == "question_generated",
                    UsageEventTable.created_at >= cutoff,
                )
                .count()
            )

        return count

    def _count_answers_in_window(self, user_id: str, days: int) -> int:
        """Count answers submitted in window."""
        cutoff = datetime.now(UTC) - timedelta(days=days)

        with self.storage.SessionLocal() as session:
            count = (
                session.query(UsageEventTable)
                .filter(
                    UsageEventTable.user_id == user_id,
                    UsageEventTable.event_type == "answer_submitted",
                    UsageEventTable.created_at >= cutoff,
                )
                .count()
            )

        return count
